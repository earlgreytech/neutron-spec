In this the various x86 components of Neutron's initial release will be described.

# The qx86 VM

The qx86 VM is designed specifically to remove unneeded functionality and to reduce complexity. The x86 machine architecture is famously complex and by limiting the scope of this VM, that complexity can be greatly reduced, while also enabling about significant performance optimizations. 

The specific subset is defined as so:

* The i686 instruction set, excluding FPU, MMX, and SSE instructions
* The top bit of an address is set if accessing mutable memory (anything >2Gb)
* Segment registers are never used. Segment register override prefixes are ignored (though not invalid) and opcodes which explictly operate on segment registers including far jmps and far calls will throw an invalid opcode exception, excluding push and pop operations for segments
* Exceptions are not capable of being handled within the VM as user serviceable interrupts. For instance, if divide by zero happens, it does not trigger interrupt 0. Further more, there is no ability to register user code interrupts. Interrupts are always a system call which will exit the VM
* Each opcode can be no larger than 16 bytes (i686 specification limit)
* From the beginning of each opcode's location in memory, at least 16 bytes must be readable afterwards. This means that in a memory the size of 100 bytes, no reachable opcode can be placed after the 84th byte
* There is no allowances for paging-like setups or memory mapped devices, including memory mapped hypervisor system calls
* All values in EFLAGS are ignored and treated as 0 except for AF, CF, ZF, PF, and SF
* External interrupt behavior is completely ignored, there is no external interrupt support
* All memory below 0x10000 is inaccessible. This makes 16-bit addressing useless aside from with LEA. Aside from LEA, any other opcode with an address override prefix will be treated as an invalid opcode.
* There is no external interrupt mechanism, greatly simplifying the behavior of some opcodes and allowing for more pipeline assumptions that benefit performance
* All memory sections added to the VM must be aligned on a 16 bit border, or 64Kb alignment. 

The instruction set supported is a subset of i686. All common opcodes generated by compilers will be supported, with the exception of FPU opcodes. Opcodes which are unsupported include:

* Instructions which require priviledge (ie, ring 0 - ring 2) or are designed for the implementation of operating system features are disallowed
* Instructions which test if memory using a segment register is readable is invalid
* The BOUND instruction is invalid (never used by compilers due to unpredictable interrupt behavior) and will result in an opcode error
* IN and OUT instructions (and variants) are not implemented and will result in an opcode error
* It is effectively impossible to use 16 bit addressing mode opcodes and so this functionality will immediately trigger an error, excluding the 16 bit LEA opcode which is valid and will function properly
* The LOCK prefix is valid on all opcodes and will never trigger an error. It is treated as a NOP
* The CPUID opcode is not implemented and will trigger an opcode error
* The HLT opcode will never resume execution, it will explicitly terminate the program, as if using the interrupt `exit_execution(EAX)`
* Loading segment registers (using MOV etc) will always trigger an opcode error
* PUSH and POP operations for segment registers will function as a no-op, but will modify the stack. Specifically, pushing a segment will always result on a 0:u16 being pushed to the stack, while popping a segment will always result in the ESP register being moved appropriately, but nothing being done with the data that is on the stack

# The x86 Hypervisor

The x86 Hypervisor ties into the the qx86 VM and allows for communication to and from it into Neutron. It accomplishes this by implementing a series of system calls that are exposed to smart contract programs. These system calls are simple interrupts using a consistent ABI for passing arguments etc. The hypervisor also manages the state used for a smart contract's bytecode and non-mutable data, as well as interpreting data from Neutron which can result in either a smart contract creation or call. 

## x86 Interrupts

The 32-bit registers used for passing in data to a system call are, in order:

* EAX
* ECX
* EDX

The registers which can be used for returning data from a system call are:

* EAX
* EDX (only for 64 bit data)

If more data is needed, or if dynamic length data is used, then the ComStack should be used. 

For reference, given an interrupt of the format `do_stuff(foo, bar, baz, fam) -> zam:u64` the register usage would be as so for input:

* EAX = foo
* ECX = bar
* EDX = baz
* first item popped from comstack = fam

And as so for output:

* EAX = lower 32 bits of zam
* EDX = upper 32 bits of zam

The list of operations supported by x86 interrupts are:

Note all operations here unless specified are classified as "pure". "variable" means that the type of operation may be pure or another type depending on exact arguments etc. 

ComStack operations:

* Interrupt 0x10: push_comstack (buffer, size)
* Interrupt 0x11: pop_comstack (buffer, max_size) -> actual_size: u32 -- note: if buffer and max_size is 0, then the item will be popped without copying the item to memory and only the actual_size will be returned
* Interrupt 0x12: peek_comstack (buffer, max_size, index) -> actual_size: u32 -- note: if buffer and max_size is 0, then this function can be used solely to read the length of the item. 
* Interrupt 0x14: dup_comstack() -- will duplicate the top item on the stack
* Interrupt 0x15: comstack_item_count() -> size:u32 -- will get the number of items on the stack
* Interrupt 0x16: comstack_memory_size() -> size:u32 -- will get the total size of all items on the stack
* Interrupt 0x17: comstack_memory_remaining() -> size:u32 -- will get the remaining total size that is allowed to be used within this execution
* Interrupt 0x18: comstack_item_limit_remaining() -> size:u32 -- will get the total remaining number of items that can be pushed onto the stack
* Interrupt 0x19: comstack_clear() -- Will clear the stack completely, without giving any information about what was held on the stack

Call System Functions:

* Interrupt 0x20: system_call(feature, function):variable -> error:u32 -- will call into the NeutronCallSystem

Hypervisor Functions:

* Interrupt 0x80: alloc_memory TBD

Context Functions:

* Interrupt 0x90: gas_limit() -> limit:u64 -- Will get the total amount of gas available for the current execution
* Interrupt 0x91: self_address() -- result on stack as NeutronShortAddress -- Will return the current address for the execution. For a "one-time" execution, this will return a null address
* Interrupt 0x92: origin() -- result on stack as NeutronShortAddress -- Will return the original address which caused the current chain of executions
* Interrupt 0x93: origin_long() -- result on stack as NeutronLongAddress
* Interrupt 0x94: sender() -- result on stack as NeutronShortAddress -- Will return the address which caused the current execution (and not the entire chain)
* Interrupt 0x95: sender_long() -- result on stack as NeutronLongAddress
* Interrupt 0x96: value_sent() -> value:u64 -- The total amount of Qtum sent with the execution
* Interrupt 0x97: nest_level() -> level:u32 -- The number of times the current contract address is on the ContextStack. For example, the nest_level of A in the case of `A -> B -> C -> A -> D -> A` will be 3.
* Interrupt 0x98: gas_remaining() -> gas:u64 -- The total amount of gas remaining for the current execution
* Interrupt 0x99: execution_type() -> type:u32 -- The type of the current execution (see built-in types)
* Interrupt 0x9A: execution_permissions() -> permissions:u32 -- The current permissions of the execution (see built-in types)

Contract Management Functions:

* Interrupt 0xA0: upgrade_code_section(id: u8, bytecode: [u8]):mutable
* Interrupt 0xA1: upgrade_data_section(id: u8, data: [u8]):mutable
* Interrupt 0xA2: upgrade_abi_format(new_format: u8):mutable
* Interrupt 0xA3: upgrade_abi_type(new_type: u64):mutable -- new_type is pushed to the ComStack
* Interrupt 0xA4: get_data_section(id: u8) -> data: [u8] --there is no code counter type provided because it can be read directly from memory. Data can as well, but may have been modified during execution


System Functions:

* Interrupt 0xFE: revert_execution(status) -> noreturn -- Will revert the current execution, moving up the chain of execution to return to the previous contract, and reverting all state changes which occured within the current execution
* Interrupt 0xFF: exit_execution(status) -> noreturn -- Will exit the current execution, moving up the chain of execution to return to the previous contract. State changes will only be committed if the entire above chain of execution also exits without any reverting operations. 

## x86 Memory Map

The x86 memory map is as follows:

* 0x10000, immutable, first code memory
* 0x20000, immutable, second code memory
* ... up to 16 code memories
* 0x80010000, mutable, first data memory
* 0x80020000, mutable, second data memory
* ... up to 16 data memories
* 0x81000000, 8Kb, mutable, stack memory (for the x86 stack)
* 0x82000000, ??? size, mutable, aux memory, loaded always as 0 and can be used as an extra RAM area

## Internal State

The data and code of a smart contract are stored separately within NeutronDB. The keys are as so:

* 0x01 00 -- first code section
* 0x01 01 -- second code section
* ... up to 16 code sections
* 0x02 00 -- first data section
* 0x02 01 -- second data section
* ... up to 16 data sections

These memory sections can be conveniently be split up and used by ELF sections in smart contract compilation which can then be parsed by a Neutron tool to remove the complexities of the ELF format, leaving only a list of memory sections with corresponding target addresses.

## Contract Creation

Contract creation is done using a specialized ABI and the ComStack. The order of elements on the comstack (in pop order) are as follows:

* VM Version info (currently unspecified)
* Section Info (specifies number of code and data sections follow)
* Code section 1
* Code section 2
* ...
* Data section 1
* Data section 2
* ...
* Contract accessible data etc follows (not used by hypervisor)

## Initial CPU State

The expected initial state when VM execution begins is all registers and flag values set to 0, excluding EIP being set to 0x10000, where execution will begin, and the following memory areas will be loaded:

* 1st code section
* stack memory accessible
* aux memory accessible

The following behavior will describe the code segment:

* Base Address = 0
* Segment Limit = 0xFFFFF
* Granularity = true (Segment Limit is express in 4096 byte pages)
* Default operand size = true (32 bit operations by default)
* Long = false (not 64-bit mode)
* Present = true (using this segment will not cause an error)
* Descriptor privilege level = 3 (ring 3 access to this descriptor)
* Type = true (segment is a code segment descriptor)
* Conforming = true (code may be accessed from less privileged levels, no-op)
* Readable = true (code segment is readable)
* Accessed = N/A no-op

The following behavior will describe the data and stack segment:

* Base Address = 0
* Segment Limit = 0xFFFFF
* Granularity = true (Segment Limit is express in 4096 byte pages)
* Big = true
* Long = false (not 64-bit mode)
* Present = true (using this segment will not cause an error)
* Descriptor privilege level = 3 (ring 3 access to this descriptor)
* Type = true (segment is a code segment descriptor)
* Expand-Down = true on stacks (stacks grow down; this is a standard behavior in almost all x86 operating systems), false on data
* Writable = true (data/stack segment is writeable)
* Accessed = N/A no-op

Note that segment behavior is not enforced, for instance, writing data using a CS segment override will not result in an error.

## Loading Memory Areas

Each code section and data section which is attempted to be accessed by the VM will result in loading that section from NeutronDB without any smart contract visible error (unless the section does not exist). This will incur a memory size gas cost as well as the gas cost for loading the state from NeutronDB. There is no explicit operation to load or unload memory and it is instead done implicitly by trying to access that memory

Note that in the case of one-time executions, no state will be stored in NeutronDB for the contract, nor will any state be loaded (except by external contract calls and external state loads) from NeutronDB. Instead, the entire set of code and data memory data will be stored within the transaction data and loaded into the Hypervisor via the ComStack. 

## Built-in Types

The following definitions (in Rust) are used for NeutronShortAddress and NeutronFullAddress

    #[repr(C)]
    pub struct NeutronShortAddress{
        pub version: u32,
        pub data: [u8; 20]
    }

    #[repr(C)]
    pub struct NeutronFullAddress<'a>{
        pub version: u32,
        pub data: &'a [u8]
    }

NeutronShortaddress is a fixed size, 24 byte structure which can be used for all address uniqueness and identification purposes, however, it can not be used for sending Qtum to an address EXCLUDING perfect-conversion addresses. Perfect-conversion addresses are address types which can be converted perfectly from a short address to a full address. In otherwords, the entire address can be contained within 24 bytes. NeutronFullAddress is a dynamic length structure which contain an address of any size and can be used for sending Qtum. For simplicity and lower resource usage, the short form of an address should be used in all places where possible. It is possible to convert a full address to a short address, but not always the other way around. 

The following constants are also defined:

    EXECUTION_TYPE_CALL     = 0
    EXECUTION_TYPE_DEPLOY   = 1
    EXECUTION_TYPE_ONE_TIME = 2

* CALL -- A call from a transaction or from an external contract into an existing smart contract
* DEPLOY -- A new smart contract is being deployed
* ONE_TIME -- A piece of smart contract code is being executed which has not and will not be saved to the blockchain permanently and will not be assigned an account/address 

Execution Permissions can be one or more of the following flags:

* Mutable call -- standard mutable call with no restrictions
* static call -- A static call which can read external contract and otherwise mutable internal data, but can not modify any data or make mutable calls
* Pure call -- a restricted pure call which can only read immutable internal data and can not otherwise access any external data and can not modify any data or make any mutable or static calls.

Defined as so:

    EXECUTION_PERMS_MUTABLE     = 1
    EXECUTION_PERMS_STATIC      = 2
    EXECUTION_PERMS_PURE        = 4

All smart contract APIs for checking this, should be a bitwise comparison:

    if (permissions & EXECUTION_PERMS_MUTABLE) > 0
        //capable of doing everything a mutable call can
    if (permissions & EXECUTION_PERMS_STATIC) > 0
        //capable of doing everything a static call can
    if (permissions & EXECUTION_PERMS_PURE) > 0
        //capable of doing everything a pure call can

Furthermore, in order to express that an execution is mutable (which would incldue the permissions for static and pure) it should be written as so:

    permissions = EXECUTION_PERMS_MUTABLE + EXECUTION_PERMS_STATIC + EXECUTION_PERMS_PURE

All unspecified bits are reserved for future additions to these permissions. In the case of a permission being created that is even more restrictive than "pure", then none of these flags should be set. In the case of a permission being created which gives more power than "mutable", then all of these flags should be set, along with a new flag conveying this new permission.

## Hypervisor Internal State

All qx86 internal state has a prefix of `01`. It specifically stores the following state:

* `0100` - `010F` -- code section state
* `0110` - `011F` -- data section state

Note that this state is affected by state rent and is restored via the typical methods and persisted by actually using the code/data sections within a smart contract execution.


