In this the various x86 components of Neutron's initial release will be described.

# The qx86 VM

The qx86 VM is designed specifically to remove unneeded functionality and to reduce complexity. The x86 machine architecture is famously complex and by limiting the scope of this VM, that complexity can be greatly reduced, while also enabling about significant performance optimizations. 

The specific subset is defined as so:

* The i686 instruction set, excluding FPU, MMX, and SSE instructions
* The top bit of an address is set if accessing mutable memory (anything >2Gb)
* Segment registers are never used. Segment register override prefixes are ignored (though not invalid) and opcodes which explictly operate on segment registers including far jmps and far calls will throw an invalid opcode exception
* Exceptions are not capable of being handled within the VM as user serviceable interrupts. For instance, if divide by zero happens, it does not trigger interrupt 0. Further more, there is no ability to register user code interrupts. Interrupts are always a system call which will exit the VM
* Each opcode can be no larger than 16 bytes (i686 specification limit)
* From the beginning of each opcode's location in memory, at least 16 bytes must be readable afterwards. This means that in a memory the size of 100 bytes, no reachable opcode can be placed after the 84th byte
* There is no allowances for paging-like setups or memory mapped devices, including memory mapped hypervisor system calls
* All values in EFLAGS are ignored and treated as 0 except for AF, CF, ZF, PF, and SF
* External interrupt behavior is completely ignored, there is no external interrupt support
* All memory below 0x10000 is inaccessible. This makes 16-bit addressing useless aside from with LEA. Aside from LEA, any other opcode with an address override prefix will be treated as an invalid opcode.
* There is no external interrupt mechanism, greatly simplifying the behavior of some opcodes and allowing for more pipeline assumptions that benefit performance
* All memory sections added to the VM must be aligned on a 16 bit border, or 64Kb alignment. 

The instruction set supported is a subset of i686. All common opcodes generated by compilers will be supported, with the exception of FPU opcodes. Opcodes which are unsupported include:

* Instructions which require priviledge (ie, ring 0 - ring 2) or are designed for the implementation of operating system features are disallowed
* Instructions which test if memory using a segment register is readable is invalid
* The BOUND instruction is invalid (never used by compilers due to unpredictable interrupt behavior)
* IN and OUT instructions (and variants) are not implemented
* It is effectively impossible to use 16 bit addressing mode opcodes and so this functionality will immediately trigger an error, excluding the 16 bit LEA opcode which is valid and will function properly
* The LOCK prefix is valid on all opcodes and will never trigger an error. It is treated as a NOP
* The CPUID opcode is not implemented and will trigger an error
* The HLT opcode will never resume execution, it will explicitly terminate the program
* Loading segment registers (using MOV etc) will always trigger an error
* PUSH and POP operations for segment registers will function as a no-op, but will modify the stack

# The x86 Hypervisor

The x86 Hypervisor ties into the the qx86 VM and allows for communication to and from it into Neutron. It accomplishes this by implementing a series of system calls that are exposed to smart contract programs. These system calls are simple interrupts using a consistent ABI for passing arguments etc. The hypervisor also manages the state used for a smart contract's bytecode and non-mutable data, as well as interpreting data from Neutron which can result in either a smart contract creation or call. 

## x86 Interrupts

The 32-bit registers used for passing in data to a system call are, in order:

* EAX
* ECX
* EDX

The registers which can be used for returning data from a system call are:

* EAX
* EDX (only for 64 bit data)

If more data is needed, or if dynamic length data is used, then the ComStack should be used. 

For reference, given an interrupt of the format `do_stuff(foo, bar, baz, fam) -> zam:u64` the register usage would be as so for input:

* EAX = foo
* ECX = bar
* EDX = baz
* first item popped from comstack = fam

And as so for output:

* EAX = lower 32 bits of zam
* EDX = upper 32 bits of zam

The list of operations supported by x86 interrupts are:

ComStack operations:

* Interrupt 0x10: push_comstack (buffer, size)
* Interrupt 0x11: pop_comstack (buffer, max_size) -> actual_size: u32
* Interrupt 0x12: peek_comstack (buffer, max_size, index) -> actual_size: u32
* Interrupt 0x13: swap_comstack (index)
* Interrupt 0x14: dup_comstack()
* Interrupt 0x15: comstack_item_count() -> size:u32
* Interrupt 0x16: comstack_memory_size() -> size:u32
* Interrupt 0x17: comstack_memory_remaining() -> size:u32
* Interrupt 0x18: comstack_item_limit_remaining() -> size:u32
* Interrupt 0x19: comstack_clear()

Call System Functions:

* Interrupt 0x20: system_call(feature, function) -> error:u32

Hypervisor Functions:

* Interrupt 0x80: alloc_memory TBD

Context Functions:

* Interrupt 0x90: gas_limit() -> limit:u64
* Interrupt 0x91: self_address() -- result on stack as NeutronShortAddress
* Interrupt 0x92: origin() -- result on stack as NeutronShortAddress
* Interrupt 0x93: origin_long() -- result on stack as NeutronLongAddress
* Interrupt 0x94: sender() -- result on stack as NeutronShortAddress
* Interrupt 0x95: sender_long() -- result on stack as NeutronLongAddress
* Interrupt 0x96: value_sent() -> value:u64
* Interrupt 0x97: nest_level() -> level:u32
* Interrupt 0x98: gas_remaining() -> gas:u64
* Interrupt 0x99: execution_type() -> type:u32

System Functions:

* Interrupt 0xFE: revert_execution(status) -> noreturn
* Interrupt 0xFF: exit_execution(status) -> noreturn

## x86 Memory Map

* 0x10000, immutable, first code memory
* 0x20000, immutable, second code memory
* ... up to 16 code memories
* 0x80010000, mutable, first data memory
* 0x80020000, mutable, second data memory
* ... up to 16 data memories
* 0x81000000, 8Kb, mutable, stack memory (for the x86 stack)
* 0x82000000, ??? size, mutable, aux memory, loaded always as 0 and can be used as an extra RAM area

## Internal State

The data and code of a smart contract are stored separately within NeutronDB. The keys are as so:

* 0x01 00 -- first code section
* 0x01 01 -- second code section
* ... up to 16 code sections
* 0x02 00 -- first data section
* 0x02 01 -- second data section
* ... up to 16 data sections

## Contract Creation

Contract creation is done using a specialized ABI and the ComStack. The order of elements on the comstack (in pop order) include:

* VM Version info (currently unspecified)
* Section Info (specifies number of code and data sections follow)
* Code section 1
* Code section 2
* ...
* Data section 1
* Data section 2
* ...
* Contract accessible data etc follows (not used by hypervisor)

## Initial CPU State

The expected initial state when VM execution begins is all registers and flag values set to 0, excluding EIP being set to 0x10000, and the following memory areas being loaded:

* 1st code section
* stack memory accessible
* aux memory accessible

## Loading Memory Areas

Each code section and data section which is attempted to be accessed by the VM will result in loading that section from NeutronDB. This will incur a memory size cost as well as the cost from loading the state from NeutronDB. There is no explicit operation to load or unload memory and it is instead done implicitly by trying to access that memory


## Built-in Types

The following definitions (in Rust) are used for NeutronShortAddress and NeutronFullAddress

    #[repr(C)]
    pub struct NeutronShortAddress{
        pub version: u32,
        pub data: [u8; 20]
    }

    #[repr(C)]
    pub struct NeutronFullAddress<'a>{
        pub version: u32,
        pub data: &'a [u8]
    }

NeutronShortaddress is a fixed size, 24 byte structure which can be used for all address uniqueness and identification purposes, however, it can not be used for sending Qtum to an address EXCLUDING perfect-conversion addresses. Perfect-conversion addresses are address types which can be converted perfectly from a short address to a full address. In otherwords, the entire address can be contained within 24 bytes. NeutronFullAddress is a dynamic length structure which contain an address of any size and can be used for sending Qtum. For simplicity and lower resource usage, the short form of an address should be used in all places where possible. It is possible to convert a full address to a short address, but not always the other way around. 





